# HashMap原理

### 	**put方法底层实现：**

​		a、判断当前HashMap的table数组是否为空，若是则初始化数组，将初始化的阈值(数组容量)传入初始化数组的方法，若不是空则不做初始化。

​		b、判断key是否为null，若不是先调用hashCode方法计算hash值再对其进行异或和右移运算提高散列性能(**右移：高位补0，低位舍掉**)，若是则单独处理，只会放在数组的第一个元素。

​		c、将b中算出的hash值与数组长度-1(**确保数组下标计算的值在0--数组长度之间**)进行与&操作。计算put的数组下标。(**&操作：都为1则为1**)

​		d、从头节点开始遍历链表。若hash值相同则先拿出该位置的元素，将新元素放到链表的头部，并next指向刚才拿出来的那个元素，并且size++。

**1、HashMap插入新元素若hash值相同，则将新元素放入链表头部(效率高)，只需要指定next指向原链表的第一个元素，原链表第一个元素下移。**

**2、为什么要用2的幂次方作为数组的大小？**

​	确保长度的二进制数只有一位是1，为计算put元素时计算数组下标做准备。

**3、为什么要对key的hash值再进行右移以及异或运算？**

​	a、增加散列性。

​	b、让key的hash值在计算数组下标的时候都参与进来，是的map的散列性更好。

**4、put方法有返回值，若put的key已在map中存在则有返回值返回的类型是value的类型，若put的key不存在则返回null。**

**5、HashMap若需要扩容，jdk1.7中在元素put进去之前进行扩容。**

**6、HashMap的size方法直接返回map的size属性值。**

**7、jdk1.7之后在size大于等于阈值(数组长度乘以加载因子)以及put的位置已有元素则会自动扩容，扩容之前的数组长度乘以2。**

**8、重写equals方法，必须重写hashCode方法。**

